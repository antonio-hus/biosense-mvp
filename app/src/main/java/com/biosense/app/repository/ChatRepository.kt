package com.biosense.app.repository

import com.biosense.app.data.dao.ChatDao
import com.biosense.app.data.entity.ChatMessageEntity
import com.biosense.app.data.entity.ChatSessionEntity
import com.biosense.app.service.api.IGeminiApiService
import kotlinx.coroutines.flow.Flow
import java.util.UUID

/**
 * Central repository for managing Chat Data.
 * Coordinates between local Room database (persistence) and remote Gemini API (intelligence).
 * Handles the business logic of sending messages, managing session state, and parsing AI commands.
 */
class ChatRepository(
    private val chatDao: ChatDao,
    private val apiService: IGeminiApiService
) {

    /** Observes the list of all chat sessions, updated in real-time. */
    val allSessions: Flow<List<ChatSessionEntity>> = chatDao.getAllSessions()

    /** Observes messages for a specific session ID. */
    fun getMessages(sessionId: String): Flow<List<ChatMessageEntity>> {
        return chatDao.getMessagesForSession(sessionId)
    }

    /**
     * Fetches the last N messages synchronously.
     * Used to build the "Chat History" context for the AI prompt.
     */
    suspend fun getRecentMessages(sessionId: String, limit: Int): List<ChatMessageEntity> {
        return chatDao.getRecentMessages(sessionId, limit)
    }

    /** Generates a default title like "Conversation #5" based on current count. */
    suspend fun generateNewSessionTitle(): String {
        val count = chatDao.getSessionCount() + 1
        return "Conversation #$count"
    }

    /**
     * Explicitly creates a session with a specific ID.
     * CRITICAL: Must match the temporary ID generated by the ViewModel to ensure UI consistency.
     */
    suspend fun createSessionWithId(id: String, title: String) {
        val newSession = ChatSessionEntity(id = id, title = title)
        chatDao.insertSession(newSession)
    }

    /**
     * Core logic for sending a message.
     * 1. Ensures session exists in DB.
     * 2. Saves user message to DB (optimistic UI update).
     * 3. Calls Gemini API.
     * 4. Parses and strips hidden context commands (e.g. [SET_CONTEXT:...]).
     * 5. Saves cleaned AI response to DB.
     *
     * @param sessionId The UUID of the current chat session.
     * @param displayText The clean text message shown to the user.
     * @param aiPrompt The full engineered prompt sent to Gemini (includes User Profile + Health Data).
     * @param isFirstMessage Flag to trigger session creation if needed.
     * @return The new context string if the AI requested an update (e.g., "User has flu"), or null.
     */
    suspend fun sendMessage(
        sessionId: String,
        displayText: String,
        aiPrompt: String,
        isFirstMessage: Boolean
    ): String? {

        // Ensure Session Exists (Using the exact sessionId passed from ViewModel)
        // This prevents ID mismatch where UI watches one ID and Repo creates another.
        if (isFirstMessage) {
            val existing = chatDao.getSessionById(sessionId)
            if (existing == null) {
                val title = generateNewSessionTitle()
                createSessionWithId(sessionId, title)
            }
        }

        // Insert User Message immediately
        // Since the ViewModel observes the DB flow, this triggers an instant UI update.
        val userMsg = ChatMessageEntity(
            sessionId = sessionId,
            text = displayText,
            isUser = true
        )
        chatDao.insertMessage(userMsg)

        // 3. Call AI Service
        try {
            val fullResponse = apiService.generateResponse(aiPrompt)

            // 4. Parse SET_CONTEXT command
            // The AI can output [SET_CONTEXT: New State] to update user profile memory.
            val updateRegex = "\\[SET_CONTEXT:(.*?)\\]".toRegex()
            val match = updateRegex.find(fullResponse)

            // Extract the new context state (if present)
            val newContextState = match?.groupValues?.get(1)?.trim()

            // Clean the response for display (remove the hidden command)
            val displayResponse = fullResponse.replace(updateRegex, "").trim()

            // 5. Insert AI Message
            val aiMsg = ChatMessageEntity(
                sessionId = sessionId,
                text = displayResponse,
                isUser = false
            )
            chatDao.insertMessage(aiMsg)

            return newContextState

        } catch (e: Exception) {
            // On network error, save a friendly error message to the chat.
            val errorMsg = ChatMessageEntity(
                sessionId = sessionId,
                text = "I'm having trouble connecting right now. Please try again.",
                isUser = false
            )
            chatDao.insertMessage(errorMsg)
            return null
        }
    }

    /**
     * Deletes the current session and all associated messages.
     * @param sessionId The ID of the session to delete.
     */
    suspend fun deleteSession(sessionId: String) {
        chatDao.deleteSession(sessionId)
    }

    /**
     * Updates the title of a session.
     * @param sessionId The ID of the session to update.
     * @param newTitle The new title for the session.
     */
    suspend fun renameSession(sessionId: String, newTitle: String) {
        chatDao.updateSessionTitle(sessionId, newTitle)
    }
}
